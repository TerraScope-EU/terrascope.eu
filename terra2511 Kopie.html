<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TerraScope</title>
<!-- Gothic Fraktur Webfont (Google Fonts Alternative: UnifrakturCook) -->
<link href="https://fonts.googleapis.com/css2?family=UnifrakturCook:wght@700&display=swap" rel="stylesheet">
<style>
body {
  margin: 0;
  background: #000;
  color: #fff;
  font-family: 'Arial', sans-serif;
  overflow-x: hidden;
}

canvas {
  border-radius: 14px;
  display: block;
  margin: 0 auto;
}

h1 {
  font-size: 48px;
  font-weight: 700;
  margin: 30px 0 0 0;
  text-align: center;
  background: linear-gradient(90deg,#9ef0d6,#00c7a3);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

/* =================== Tree Structure =================== */
.tree-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 20px auto;
  max-width: 800px;
}

.tree-container details {
  text-align: center;
  border-left: 2px solid #00c7a3;
  border-right: 2px solid #00c7a3;
  padding: 6px 8px;  /* Kontur näher an Text */
  border-radius: 6px;
  margin-bottom: 10px;
  transition: all 0.3s ease;
}

/* Organischer Stamm: oben zart, unten ca. 15% breiter */
.tree-container details:nth-child(1) { width: 35%; }
.tree-container details:nth-child(2) { width: 36%; }
.tree-container details:nth-child(3) { width: 37%; }
.tree-container details:nth-child(4) { width: 38%; }
.tree-container details:nth-child(5) { width: 39%; }
.tree-container details:nth-child(6) { width: 40%; }
.tree-container details:nth-child(7) { width: 41%; }
.tree-container details:nth-child(8) { width: 42%; }
.tree-container details:nth-child(9) { width: 43%; }

.tree-container summary {
  cursor: pointer;
  list-style: none;
  font-size: 18px;
  font-weight: 600;
  color: #cdece4;
}

.tree-container summary::-webkit-details-marker {
  display: none;
}

.tree-container summary::after {
  content: "▼";
  display: block;
  font-size: 12px;
  margin: 4px auto 0 auto;
}

.tree-container div {
  font-size: 16px;
  line-height: 1.4;
  margin-top: 8px;
  color: #cdece4;
}

.footer {
  text-align: center;
  margin: 50px 0 30px 0;
  color: #777;
  font-size: 14px;
}

.gothic-title {
  font-family: 'UnifrakturCook', 'Engravers Fraktur', 'Gutenberg', serif;
  font-size: 64px;
  font-weight: 700;
  text-align: center;
  margin: 24px 0 0 0;
  letter-spacing: 0.04em;
  color: #cdece4;
  opacity: 0.55;
  background: none;
  transition: opacity 0.3s, filter 0.3s;
  pointer-events: none;
  user-select: none;
}
</style>
</head>
<body>

<div style="position:relative; width:100%;">
  <canvas id="terra_canvas" width="1200" height="620" style="display:block; margin:0 auto; position:relative; z-index:1;"></canvas>
  <!-- Gothic Title centered over the animation -->
  <div id="gothicTitle" class="gothic-title" style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:2; width:100%; text-align:center; pointer-events:none;">TERRASCOPE</div>
</div>

<div class="tree-container">
  <details>
    <summary>Mission & Rationale</summary>
    <div>Why TerraScope Exists
Europe needs an autonomous, ground-based environmental intelligence layer that complements—not competes with—LEO missions. TerraScope delivers resilient, emission-free observation through a terrestrial optical mesh, enabling real-time insight into climate, agriculture, biodiversity, and crisis situations.</div>
  </details>
  <details>
    <summary>System Architecture</summary>
    <div>Decentralised Optical & Sensor Network
A continental mesh of ground nodes, each capturing high-resolution optical and environmental data. Nodes communicate via secure ground-to-ground links and an optional GEO relay. Edge-processing reduces bandwidth, produces local alerts, and ensures operation even during communication outages.</div>
  </details>
  <details>
    <summary> Development Roadmap</summary>
    <div>Four Strategic Phases
	1.	Field Integration – Early prototypes, agricultural pilots, and partner validation.
	2.	Network Formation – Regional optical and radio linking of nodes.
	3.	Rollout – Continental coverage, early-warning capabilities, agri-intelligence, climate monitoring.
	4.	GEO Layer (Optional) – Precision calibration, sky-mapping, large-scale 3D reconstruction.</div>
  </details>
  <details>
    <summary>Environmental & Agricultural Intelligence</summary>
    <div>Real-Time Insights for Soil, Crops & Ecosystems
Nodes collect long-interval image sequences and sensor data to analyse soil structure, crop performance, water dynamics, biodiversity patterns, and field variability. Designed to help farmers, researchers, and agencies optimise interventions and track environmental change.</div>
  </details>
  <details>
    <summary>Collaboration & Partnerships</summary>
    <div>Opportunities for Technical, Scientific & Policy Actors
TerraScope offers integration points for photonics, edge-AI, hydrology, biodiversity science, manufacturing, logistics, governance, and EU knowledge hubs. The system is designed for joint development, shared indicators, and coordinated validation.</div>
  </details>
  <details>
    <summary>Research Integration</summary>
    <div>Climate, Biodiversity & Hydrology Alignment
Supports predictive modelling, anomaly detection, long-term datasets, and multi-site observation campaigns. Enables harmonised protocols and cross-border collaboration across academic and institutional partners.</div>
  </details>
  <details>
    <summary>Governance, Security & Ethic</summary>
    <div>Legal Compliance, Data Stewardship & Cybersecurity
Framework for GDPR alignment, transparent data handling, secure telemetry, ethical AI integration, and environmental-risk protocols. Ensures responsible management of decentralised environmental networks.</div>
  </details>
  <details>
    <summary>Impact & Communication</summary>
    <div>Societal Value, Public Engagement & Knowledge Transfer
Transforms complex observations into accessible tools for communities, farmers, decision-makers, and educators. Encourages citizen involvement and strengthens environmental literacy and policy impact across EU regions.</div>
  </details>
  <details>
    <summary>Implementation & Deployment</summary>
    <div>Scalable Production, Operations & Field Management
Covers manufacturing pathways, circular-economy principles, installation logistics, multi-site coordination, QA procedures, and operational risk monitoring. Ensures robust deployment at continental scale with long-term maintainability.</div>
  </details>
</div>

<div class="footer">
  © TerraScope — 2025 | Straight. Clear. Alive.
</div>

<script>
// =================== TerraScope JS (Animation Krone) ===================

// RNG Funktion
function RNG(seed = 1337){
  let s = seed >>> 0;
  return function() {
    s ^= s << 13; s ^= s >>> 17; s ^= s << 5;
    return ((s >>> 0) / 4294967295);
  };
}

// Polygon für Grenzen
function euPath(n=2200){
  const p = [];
  for(let i=0;i<n;i++){
    const θ = i/n * Math.PI*2;
    const r = 5.12 + 2.48*Math.cos(θ) + 1.62*Math.cos(2*θ) + 0.94*Math.sin(3*θ)
            -1.30*Math.cos(4*θ) + 0.78*Math.cos(6*θ) + 1.12*Math.pow(Math.cos(5*θ),3)
            +1.02*Math.exp(-32*(θ-1.05)**2)-0.68*Math.exp(-48*(θ+1.32)**2)
            +0.38*Math.tanh(3*θ)+0.36*Math.sin(8*θ);
    const x = 0.5 + 0.0618*(r*Math.cos(θ) + 0.46*Math.sin(7*θ));
    const y = 0.5 + 0.0618*(r*Math.sin(θ) + 1.12*Math.tanh(3*θ) + 0.32*Math.sin(9*θ));
    p.push({x,y});
  }
  return p;
}

// Canvas Setup
const canvas = document.getElementById('terra_canvas');
const ctx = canvas.getContext('2d', { alpha: false });
let dpr = window.devicePixelRatio || 1;
let W=0,H=0;

function fitCanvas(){
  const r = canvas.getBoundingClientRect();
  W = Math.max(600, Math.floor(r.width));
  H = Math.max(300, Math.floor(r.height));
  canvas.width = Math.floor(W*dpr);
  canvas.height = Math.floor(H*dpr);
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
fitCanvas();
window.addEventListener('resize', ()=>{ clearTimeout(window._fit); window._fit = setTimeout(fitCanvas,120); });

function pointInPoly(px, py, poly){
  let inside=false;
  for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const a=poly[i], b=poly[j];
    if(((a.y>py)!=(b.y>py)) && (px < (b.x-a.x)*(py-a.y)/(b.y-a.y+1e-12)+a.x)) inside=!inside;
  }
  return inside;
}

// =================== Nodes & Edges ===================
const rnd = RNG(987654321);
const boundary = euPath(2400);
const NODES = [];
(function genNodes(){
  const attempts = 4500;
  for(let i=0;i<attempts && NODES.length < 420;i++){
    const bx = Math.pow(rnd(),0.9)*0.78 + 0.11;
    const by = Math.pow(rnd(),1.15)*0.78 + 0.11;
    const x = Math.min(0.94, Math.max(0.06, bx + (rnd()-0.5)*0.06));
    const y = Math.min(0.94, Math.max(0.06, by + (rnd()-0.5)*0.06));
    if(pointInPoly(x,y,boundary)){
      NODES.push({x,y,phase:rnd()*Math.PI*2,radius:1.6 + rnd()*1.8,bio:rnd()});
    }
  }
})();

const EDGES = [];
(function linkNodes(){
  const maxNeighbors = 6;
  for(let i=0;i<NODES.length;i++){
    const a = NODES[i];
    const list=[];
    for(let j=0;j<NODES.length;j++){
      if(i===j) continue;
      const b=NODES[j];
      const dx=a.x-b.x, dy=a.y-b.y;
      const d2 = dx*dx + dy*dy;
      if(d2<0.06 && d2>0.0035) list.push({j,d2});
    }
    list.sort((p,q)=>p.d2-q.d2);
    for(let k=0;k<Math.min(maxNeighbors,list.length);k++){
      const j = list[k].j;
      const key=[Math.min(i,j),Math.max(i,j)].join('-');
      if(!EDGES.some(e=>e.key===key)){
        EDGES.push({a:i,b:j,key,strength:0.28 + rnd()*0.7});
      }
    }
  }
})();

const DEEP_NODES=[];
for(let i=0;i<Math.min(220,Math.floor(NODES.length*0.5));i++){
  const n=NODES[Math.floor(rnd()*NODES.length)];
  DEEP_NODES.push({x:n.x+(rnd()-0.5)*0.02, y:n.y+(rnd()-0.5)*0.02, phase:rnd()*Math.PI*2, radius:1.0+rnd()*1.0});
}

const DEEP_EDGES=[];
for(let i=0;i<DEEP_NODES.length;i++){
  const a=DEEP_NODES[i];
  for(let j=i+1;j<DEEP_NODES.length;j++){
    const b=DEEP_NODES[j];
    const dx=a.x-b.x, dy=a.y-b.y;
    const d2 = dx*dx + dy*dy;
    if(d2<0.045 && d2>0.0018 && rnd()<0.26){
      DEEP_EDGES.push({a:i,b:j,str:0.22+rnd()*0.5});
    }
  }
}

const PULSES=[];
function spawnPulseOnEdge(edgeIndex, deep=false){
  const e = deep?DEEP_EDGES[edgeIndex]:EDGES[edgeIndex];
  if(!e) return;
  const from = deep?DEEP_NODES:NODES;
  const f = from[e.a], t = from[e.b];
  const speed=(0.0025+rnd()*0.0045)*(deep?0.6:1.0);
  PULSES.push({fromIdx:e.a,toIdx:e.b,from:f,to:t,t:0,speed,layerDeep:deep,life:1.0,hue:170+Math.floor(rnd()*40)});
}

function tickSpawn(t){
  const pcount=PULSES.length;
  // Traffic: double the spawn probability for both edge types
  if(rnd()<0.56*(1+Math.min(pcount/40,2))*0.6){
    const eidx=Math.floor(rnd()*EDGES.length);
    if(eidx<EDGES.length) spawnPulseOnEdge(eidx,false);
  }
  if(rnd()<0.28){
    const eidx=Math.floor(rnd()*DEEP_EDGES.length);
    if(eidx<DEEP_EDGES.length) spawnPulseOnEdge(eidx,true);
  }
}

// =================== Animation ===================
let lastTime=0, heartbeatTimer=0;
const HEARTBEAT_INTERVAL=8000;

// Gothic Title Animation: Interacts with Nodes & Data Traffic
const gothicTitle = document.getElementById('gothicTitle');
function updateGothicTitle(t) {
  // Calculate average node brightness
  let sum = 0;
  for (let n of NODES) {
    sum += 0.78 + 0.32 * Math.sin(t * 1.42 + n.phase);
  }
  const avg = sum / NODES.length;
  // Count active pulses (traffic)
  const traffic = Math.min(PULSES.length, 120);
  // Animate opacity, glow, and color based on node activity and traffic
  const baseOpacity = 0.38 + 0.32 * avg;
  const trafficBoost = 0.12 + 0.22 * (traffic / 120);
  gothicTitle.style.opacity = (baseOpacity + trafficBoost).toFixed(2);
  gothicTitle.style.filter = `drop-shadow(0 0 ${8 + avg * 18 + traffic * 0.5}px #00c7a3)`;
  // Slight color shift with traffic
  const hue = 170 + Math.floor(traffic * 0.3);
  gothicTitle.style.color = `hsl(${hue}, 60%, 80%)`;
}

function renderFrame(tms){
  const t = tms*0.001;
  const dt = Math.min(0.05,(tms-lastTime)/1000||0.016);
  lastTime=tms;
  const newDpr = window.devicePixelRatio || 1;
  if(newDpr!==dpr){ dpr=newDpr; fitCanvas(); }

  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#00161a'); g.addColorStop(1,'#000204');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  ctx.globalAlpha=0.12;
  ctx.fillStyle='rgba(0,8,12,1)';
  ctx.fillRect(-40,-20,W+120,H+40);
  ctx.globalAlpha=1.0;

  ctx.lineCap='round';
  for(let e of DEEP_EDGES){
    const A=DEEP_NODES[e.a], B=DEEP_NODES[e.b];
    const ax=A.x*W, ay=A.y*H, bx=B.x*W, by=B.y*H;
    ctx.lineWidth=2.6*e.str;
    ctx.strokeStyle='rgba(0,160,140,0.055)';
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    ctx.lineWidth=0.9*e.str;
    ctx.strokeStyle='rgba(0,210,180,0.12)';
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
  }

  for(let e of EDGES){
    const A=NODES[e.a], B=NODES[e.b];
    const ax=A.x*W, ay=A.y*H, bx=B.x*W, by=B.y*H;
    ctx.lineWidth=1.2*e.strength;
    ctx.strokeStyle='rgba(26,170,150,0.035)';
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    ctx.lineWidth=0.9*e.strength;
    ctx.strokeStyle='rgba(80,230,200,0.065)';
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    ctx.lineWidth=0.5*(0.6 + e.strength*0.8);
    ctx.strokeStyle='rgba(120,255,220,0.12)';
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
  }

  tickSpawn(t);
  heartbeatTimer+=dt*1000;
  if(heartbeatTimer>HEARTBEAT_INTERVAL){
    heartbeatTimer=0;
    for(let k=0;k<14;k++){
      const idx=Math.floor(rnd()*EDGES.length);
      spawnPulseOnEdge(idx,false);
    }
  }

  for(let i=PULSES.length-1;i>=0;i--){
    const p=PULSES[i];
    p.t+=p.speed*(1+Math.min(PULSES.length/60,1.5));
    if(p.t>1.01||p.life<=0){ PULSES.splice(i,1); continue; }
    const x=p.from.x + (p.to.x - p.from.x)*p.t;
    const y=p.from.y + (p.to.y - p.from.y)*p.t;
    const screenX=x*W, screenY=y*H;
    const headSize=(p.layerDeep?2.0:2.8)*(0.8+0.6*(1-Math.abs(0.5-p.t)));
    const tailCount=6;
    for(let s=0;s<tailCount;s++){
      const tt=p.t-s*0.038;
      if(tt<0) break;
      const kk=1-tt;
      const tx=p.from.x + (p.to.x-p.from.x)*tt;
      const ty=p.from.y + (p.to.y-p.from.y)*tt;
      const alpha=0.34*(1-s/tailCount)*kk*(p.layerDeep?0.9:1.0);
      const size=headSize*(1-s/(tailCount+1))*(p.layerDeep?1.0:1.0);
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createRadialGradient(screenX,screenY,0,screenX,screenY,size*1.4);
      grad.addColorStop(0, `hsla(${p.hue},88%,${p.layerDeep?55:62}%,${alpha})`);
      grad.addColorStop(1,'transparent');
      ctx.fillStyle=grad;
      ctx.beginPath(); ctx.arc(tx*W,ty*H,size*0.9,0,Math.PI*2); ctx.fill();
      ctx.globalCompositeOperation='source-over';
    }
    p.life-=0.0012;
  }

  for(let n of NODES){
    const b=0.78+0.32*Math.sin(t*1.42+n.phase);
    const sx=n.x*W, sy=n.y*H;
    ctx.globalCompositeOperation='lighter';
    const grad=ctx.createRadialGradient(sx,sy,0,sx,sy,n.radius*1.6*b);
    grad.addColorStop(0,'rgba(16,200,170,0.12)');
    grad.addColorStop(1,'transparent');
    ctx.fillStyle=grad;
    ctx.beginPath(); ctx.arc(sx,sy,n.radius*1.6*b,0,Math.PI*2); ctx.fill();
    ctx.globalCompositeOperation='source-over';
    ctx.beginPath();
    ctx.fillStyle=`rgba(120,255,220,${0.9-n.bio*0.4})`;
    ctx.arc(sx,sy,n.radius*0.9*b,0,Math.PI*2);
    ctx.fill();
  }

  updateGothicTitle(t);

  requestAnimationFrame(renderFrame);
}

requestAnimationFrame(renderFrame);
</script>

</body>
</html>